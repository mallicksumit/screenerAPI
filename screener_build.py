# -*- coding: utf-8 -*-
"""Screener_Build.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11V-hfrq11IoAim5cQXyOdG2nHqaEP_YO
"""

from selenium import webdriver
import chromedriver_autoinstaller
from flask import Flask, request, jsonify
import os
import time
import urllib.parse
import pandas as pd
import logging
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException, NoSuchElementException

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# Set your credentials here or via environment variables in Render
SCRUSER = os.getenv("SCRUSER")
SCRPASSWORD = os.getenv("SCRPASSWORD")

def build_query_string(filters):
    parts = [f"{key} {op} {val}" for (key, op, val) in filters]
    query = " AND\n".join(parts)
    return urllib.parse.quote(query)

def build_url(filters):
    base = "https://www.screener.in/screen/raw/?sort=&order=&source_id=&query="
    query_string = build_query_string(filters)
    full_url = base + query_string
    return full_url

def login_screener(driver, username, password):
    try:
        logger.info("Opening Screener login page...")
        driver.get("https://www.screener.in/login/")
        
        wait = WebDriverWait(driver, 20)
        username_field = wait.until(EC.presence_of_element_located((By.NAME, "username")))
        password_field = driver.find_element(By.NAME, "password")
        
        username_field.send_keys(username)
        password_field.send_keys(password)
        
        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']")))
        login_button.click()

        # Wait for logout link as proof of login
        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "a[href='/logout/']")))
        logger.info("Login successful.")
    except TimeoutException as e:
        driver.save_screenshot("login_error.png")
        with open("page_source_debug.html", "w", encoding="utf-8") as f:
            f.write(driver.page_source)
        logger.error(f"Login failed: {str(e)}. Screenshot saved as login_error.png")
        raise

def scrape_screened_results_paginated(driver, base_url, max_pages=5):
    driver.get(base_url)
    logger.info(f"Current URL: {driver.current_url}")
    logger.info(f"Page title: {driver.title}")
    
    all_data = []
    wait = WebDriverWait(driver, 15)  # Increased timeout
    
    for page in range(1, max_pages + 1):
        try:
            # Wait for either the table or a "no results" message
            try:
                wait.until(EC.presence_of_element_located(
                    (By.CSS_SELECTOR, "table.data-table, .no-results")
                ))
                
                # Check if no results found
                no_results = driver.find_elements(By.CSS_SELECTOR, ".no-results")
                if no_results:
                    logger.info("No results found for the query")
                    break
                
                # Process table if found
                table = driver.find_element(By.CSS_SELECTOR, "table.data-table")
                rows = table.find_elements(By.CSS_SELECTOR, "tbody tr")
                
                for row in rows:
                    cols = row.find_elements(By.TAG_NAME, "td")
                    if len(cols) < 7:
                        continue
                    all_data.append({
                        "Ticker": cols[0].text,
                        "Market Cap": cols[1].text,
                        "Price": cols[2].text,
                        "PE Ratio": cols[3].text,
                        "Dividend Yield": cols[4].text,
                        "Profit Growth 3Y": cols[5].text,
                        "Dividend Payout": cols[6].text
                    })
                
                # Try to go to next page
                try:
                    next_btn = driver.find_element(By.CSS_SELECTOR, "a[rel='next']:not(.disabled)")
                    next_btn.click()
                    time.sleep(2)  # Brief pause for page load
                except NoSuchElementException:
                    break
                    
            except TimeoutException:
                driver.save_screenshot("scrape_timeout.png")
                logger.error("Timeout waiting for results table")
                break
                
        except Exception as e:
            driver.save_screenshot("scrape_error.png")
            logger.error(f"Error during scraping: {str(e)}")
            break
            
    return all_data

@app.route('/scrape', methods=['POST'])
def scrape():
    # Optional: get filters from JSON POST payload
    filters = request.json.get('filters', [
        ("Market capitalization", ">", "500"),
        ("Price to earning", "<", "15"),
        ("Dividend yield", ">", "1.2"),
        ("Current price", ">", "100"),
        ("Profit growth 3Years", ">", "0"),
        ("Dividend Payout", ">", "30"),
    ])

    url = build_url(filters)
    
    # Configure Chrome options
    chrome_options = Options()
    chrome_options.add_argument('--headless=new')
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_options.add_argument('--disable-gpu')
    chrome_options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
    
    # Initialize driver
    driver = webdriver.Chrome(options=chrome_options)
    
    try:
        login_screener(driver, SCRUSER, SCRPASSWORD)
        data = scrape_screened_results_paginated(driver, url, max_pages=5)
        return jsonify(data)
    except Exception as e:
        logger.error(f"Error in scrape endpoint: {str(e)}")
        return jsonify({"error": str(e)}), 500
    finally:
        driver.quit()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
